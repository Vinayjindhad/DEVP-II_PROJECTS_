# -*- coding: utf-8 -*-
"""045057_Project 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1otGPSrl2uELEwj7v16SjIYt5SjC461AF
"""

import numpy as np
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
import seaborn as sns

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
matplotlib.rcParams['animation.embed_limit'] = 2**30

supermarket_sales = pd.read_csv('/content/supermarket_sales - Sheet1.csv')

# Check the first few rows to understand the structure
print(supermarket_sales.head())

# Preprocess the data
supermarket_sales = supermarket_sales[supermarket_sales['Unit price'].notnull()]
supermarket_sales['Unit price'] = supermarket_sales['Unit price'].astype(int)

# Grouping by year and summing global sales
global_sales_by_year = supermarket_sales.groupby('Unit price')['gross income'].sum()

# Create a figure for the animation
fig, ax = plt.subplots(figsize=(10, 6))

# Set the title and labels
ax.set_title('change in Unit price with Gross Income')
ax.set_xlabel('Unit price')
ax.set_ylabel('gross income')
ax.set_xlim(supermarket_sales['Unit price'].min(), supermarket_sales['Unit price'].max())
ax.set_ylim(0, global_sales_by_year.max() + 10)

line, = ax.plot([], [], label='Global Sales', color='blue')

# Initialize the line plot
def init():
    line.set_data([], [])
    return line,

# Animation update function
def animate(Unit_price):
    x = global_sales_by_year.loc[:Unit_price].index
    y = global_sales_by_year.loc[:Unit_price].values
    line.set_data(x, y)
    return line,

# Create the animation
years = np.arange(supermarket_sales['Unit price'].min(), supermarket_sales['Unit price'].max() + 1)
ani = FuncAnimation(fig, animate, init_func=init, frames=years, interval=500, blit=True)

# Display the animation in the notebook
HTML(ani.to_html5_video())

"""**Objective**	The graph shows the change in unit price with gross income. The gross income is shown on the x-axis, and the change in unit price is shown on the y-axis. The y-axis is scaled from -600 to 500, so a negative value on the y-axis means that the unit price has decreased, and a positive value means that the unit price has increased.

**Analysis**	The graph shows a positive relationship between gross income and unit price. This means that as gross income increases, the unit price also increases. However, the relationship is not linear. The graph is steeper at the lower end of the x-axis, and it becomes shallower as the x-axis increases. This means that the unit price increases more rapidly at lower levels of gross income, and it increases more slowly at higher levels of gross income.

**Interpretation**	There are a few possible explanations for this relationship. One possibility is that the producer has economies of scale. This means that it costs the producer less to produce each unit of output as they produce more units. As a result, the producer can afford to lower the unit price when they have higher levels of gross income. However, the graph does show that there is a positive relationship between the two variables.
**Naypyitaw city having product line Food and beverages with max Unit price 99.42 and gross income of 19.884 and the average Unit price 55.67213 and the average gross income 15.379369**
"""

# Grouping by year and genre, then summing global sales
genre_sales_by_year = supermarket_sales.groupby(['Unit price', 'Product line'])['gross income'].sum().unstack().fillna(0)

# Initialize the figure
fig, ax = plt.subplots(figsize=(10, 6))

def animate(Unit_price):
    ax.clear()
    sales_data = genre_sales_by_year.loc[Unit_price]
    genres = sales_data.index
    sales = sales_data.values
    ax.bar(genres, sales, color=plt.cm.Paired(np.arange(len(genres))))
    ax.set_title(f'Global margin% by Product line for {Unit_price}')
    ax.set_xlabel('Product line')
    ax.set_ylabel('gross margin percentage')
    ax.set_xticklabels(genres, rotation=45, ha='right')

# Create the animation
years = genre_sales_by_year.index
ani = FuncAnimation(fig, animate, frames=years, interval=2000)

# To display the animation
HTML(ani.to_jshtml())

"""**Objective:**
To analyze the global marginal revenue by product line for the year 1999, as shown in the graph.

**Analysis:**

The graph shows a bar chart with five bars representing different product lines: Accessories, Beverages, Entertainment, Health & Beauty, and Travel & Lifestyle.
The Y-axis represents the global marginal revenue percentage, but there is no specific scale or units indicated.
Accessories has the highest marginal revenue, at approximately 160%.
Beverages, Entertainment, and Health & Beauty appear to have similar marginal revenue percentages, ranging from around 100% to 120%.
Travel & Lifestyle has the lowest marginal revenue, at approximately 60%.

**Interpretation:**

Accessories are the most profitable product line in terms of marginal revenue, meaning that each additional unit sold contributes the highest percentage to the overall profit.
Beverages, Entertainment, and Health & Beauty are also profitable, but to a lesser extent than Accessories.
Travel & Lifestyle is the least profitable product line in terms of marginal revenue.

**The hightest Gross Income 49.65 of Product line i.e Fashion accessories**
"""

# Grouping by year and platform, then summing global sales
platform_sales_by_year = supermarket_sales.groupby(['Unit price', 'City'])['gross income'].sum().unstack().fillna(0)

# Initialize the figure
fig, ax = plt.subplots(figsize=(10, 6))

def animate(Unit_price):
    ax.clear()
    sales_data = platform_sales_by_year.loc[Unit_price]
    platforms = sales_data.index
    sales = sales_data.values
    ax.bar(platforms, sales, color=plt.cm.viridis(np.linspace(0, 1, len(platforms))))
    ax.set_title(f'gross margin percentage by City in {Unit_price}')
    ax.set_xlabel('City')
    ax.set_ylabel('gross margin percentage')
    ax.set_xticklabels(platforms, rotation=45, ha='right')

# Create the animation
years = platform_sales_by_year.index
ani = FuncAnimation(fig, animate, frames=years, interval=2000)

# To display the animation
HTML(ani.to_jshtml())

"""**Objective:**

To visualize and analyze the gross margin percentage by city for different unit prices over time.
To identify patterns and trends in gross margin performance across cities and unit prices.
 Analysis:

** Graph Elements:**

Type: Animated bar chart
Axes:
X-axis: City
Y-axis: Gross margin percentage
Data: Gross margin percentage for each city, grouped by unit price
Animation: Progresses through different unit prices over time
 Code Insights:

**Function animate**(Unit_price):
Clears the previous plot.
Extracts sales data for the given unit price from platform_sales_by_year.
Creates a bar chart with:
Cities as x-axis labels.
Gross margin percentages as bar heights.
Viridis colormap for visual clarity.
Sets informative title and labels.
Rotates x-axis labels for readability.
Animation:
Uses FuncAnimation to create an animation.
Iterates through years as frames.
Sets a 2-second interval between frames.
 Key Observations from the Graph (Based on Snapshot):

Cities: Mandalay, Naypyitaw, and Yangon are included in the analysis.
Gross Margin Ranges:
Mandalay: 40-100%
Naypyitaw: 60-140%
Yangon: 20-80%
Variations: Gross margin percentages vary significantly between cities and unit prices.
Need for Animation: The animation is crucial to understand how these variations change over time.

 **Interpretation** (Limited without Animation):

City-Specific Performance: Naypyitaw generally has the highest gross margin percentages, followed by Mandalay and then Yangon.
Unit Price Impact: Gross margin percentages likely change as unit prices change, but the specific patterns require animation to visualize.
"""

# Determine the top N publishers by total sales
top_n = 10  # You can adjust this number
top_Rating = supermarket_sales.groupby('Product line')['Rating'].sum().nlargest(top_n).index

# Filter the dataset to include only the top publishers
filtered_data = supermarket_sales[supermarket_sales['Product line'].isin(top_Rating)]

# Grouping by year and top publishers, then summing global sales
publisher_sales_by_year = filtered_data.groupby(['City', 'Product line'])['Rating'].sum().unstack().fillna(0)

# Initialize the figure for animation
fig, ax = plt.subplots(figsize=(10, 6))

def animate(year):
    ax.clear()
    sales_data = publisher_sales_by_year.loc[year]
    publishers = sales_data.index
    sales = sales_data.values
    ax.bar(publishers, sales, color=plt.cm.Accent(np.arange(len(publishers))))
    ax.set_title(f'Global Video Game Sales by Top {top_n} Publishers in {year}')
    ax.set_xlabel('Product line')
    ax.set_ylabel('Rating')
    ax.set_xticklabels(publishers, rotation=45, ha='right')

# Create the animation
years = publisher_sales_by_year.index
ani = FuncAnimation(fig, animate, frames=years, interval=500)

# To display the animation
HTML(ani.to_jshtml())

"""**Objective:**

To visualize and analyze the global video game sales performance of top publishers over time.
To identify patterns and trends in sales ratings across publishers and years.
 Analysis:

** Graph Elements:**

Type: Animated bar chart
Axes:
X-axis: Product line
Y-axis: Rating
Data: Sales ratings for top publishers, grouped by year
Animation: Progresses through different years over time
 Code Insights:

**Function animate**:
Clears the previous plot.
Extracts sales data for the given year from publisher_sales_by_year.
Creates a bar chart with:
Publishers as x-axis labels.
Sales ratings as bar heights.
Accent colormap for visual differentiation.
Sets informative title and labels.
Rotates x-axis labels for readability.
Animation:
Uses FuncAnimation to create an animation.
Iterates through years as frames.
Sets a 0.5-second interval between frames.

** Observations from the Graph **:


Rating Scale: The y-axis ranges from 0 to approximately 400.
Top Performers: In Mandalay in 1999, the top publishers have ratings between 250 and 400.
Variations: Sales ratings vary significantly between publishers.
Need for Animation: The animation is crucial to understand how these variations change over time.

** Interpretation **:

Publisher-Specific Performance: Certain publishers consistently achieve higher sales ratings than others, suggesting stronger market presence or more successful game releases.
Year-to-Year Fluctuations: Sales ratings likely change over time, reflecting industry trends, publisher strategies, and game popularity.
"""

selected_games = supermarket_sales['Payment'].unique()[:4]

# Filtering the dataset for the selected games
game_data = supermarket_sales[supermarket_sales['Payment'].isin(selected_games)]

# Grouping by year and game title, then summing global sales
game_sales_by_year = game_data.groupby(['Unit price', 'Payment'])['gross income'].sum().unstack().fillna(0)

# Initialize the figure for animation
fig, ax = plt.subplots(figsize=(10, 6))

def animate(year):
    ax.clear()
    sales_data = game_sales_by_year.loc[year]
    games = sales_data.index
    sales = sales_data.values
    ax.bar(games, sales, color=plt.cm.Paired(np.arange(len(games))))
    ax.set_title(f'Global Video Game Sales for Selected Titles in {year}')
    ax.set_xlabel('Payment')
    ax.set_ylabel('gross income')
    ax.set_xticklabels(games, rotation=45, ha='right')

# Create the animation
years = game_sales_by_year.index
ani = FuncAnimation(fig, animate, frames=years, interval=500)

# To display the animation
HTML(ani.to_jshtml())

"""**Objective:**

To visualize and analyze the global video game sales performance of selected titles over time, comparing their gross income across different payment methods.
To identify patterns and trends in sales performance for these titles, potentially revealing insights about payment preferences and market dynamics.

 **Analysis:**

 **Graph Elements:**

Type: Animated bar chart
Axes:
X-axis: Payment method
Y-axis: Gross income
Data: Gross income for selected games, grouped by payment method and year
Animation: Progresses through different years over time

 **Code Insights:**

Data Preparation:
Selects the top 3 unique payment methods from the dataset.
Filters data for games using these payment methods.
Groups data by unit price, payment method, and year, summing gross income.
Animation Function:
Clears the plot for each frame.
Extracts sales data for the given year.
Creates a bar chart with:
Payment methods as x-axis labels.
Gross income as bar heights.
Paired colormap for visual distinction.
Sets informative title and labels.
Rotates x-axis labels for readability.
Animation Creation:
Iterates through years as frames.
Sets a 0.5-second interval between frames.

 **Observations from the Graph **:


Gross Income Range: The y-axis ranges from 0 to approximately 250 .
Sales Variation: Gross income varies significantly between payment methods within the same year.
Need for Animation: The animation is crucial to understand how sales patterns change over time and across different payment methods.

 **Interpretation** :

Payment Preference: Certain payment methods generate higher gross income for the selected games in 1999 in Mandalay, suggesting potential preferences among consumers.
Temporal Trends: Sales patterns likely change over time, reflecting shifts in payment method popularity, game releases, or other factors.
"""

supermarket_sales = supermarket_sales[supermarket_sales['Quantity'].notnull() & (supermarket_sales['Quantity'] > 0)]

# List of years to iterate over
years = sorted(supermarket_sales['Unit price'].unique())

# Initialize the figure for animation
fig, ax = plt.subplots(figsize=(8, 8))
plt.xticks(rotation=45)
plt.yticks(rotation=45)

def update(Unit_price):
        data_year = supermarket_sales[supermarket_sales['Unit price'] == Unit_price]
        corr = data_year.corr()
        ax.clear()
        sns.heatmap(corr, annot=True, fmt=".2f", cmap='coolwarm', square=True, cbar=False, ax=ax)
        ax.set_title(f'Correlation Heatmap for {Unit_price}')
        plt.xticks(rotation=45)
        plt.yticks(rotation=45)

ani = FuncAnimation(fig, update, frames=years, interval=2000, repeat = False)

# To display the animation
plt.close(fig)  # Prevents duplicate display of the last frame
HTML(ani.to_html5_video())

# List of years to iterate over
years = sorted(supermarket_sales['Unit price'].unique())

# Initialize the figure for animation
fig, ax = plt.subplots(figsize=(10, 6))

def animate(Unit_price):
        ax.clear()
        # Filter data for the current year
        data_year = supermarket_sales[supermarket_sales['Unit price'] == Unit_price]['gross income']
        # Create a box plot
        ax.boxplot(data_year, vert=False, patch_artist=True)
        ax.set_title(f'Global Sales Distribution in {Unit_price}')
        ax.set_xlabel('Global Sales (Millions)')
        ax.set_ylabel('Distribution')

# Create the animation
ani = FuncAnimation(fig, animate, frames=years, interval=1000)

# To display the animation
HTML(ani.to_html5_video())

"""**Objective:**

To visualize and analyze correlations between variables in the supermarket sales dataset, focusing on how these correlations change for different unit prices.
To identify patterns and relationships that could inform pricing strategies, product recommendations, and other business decisions.

** Analysis:**

**Graph Elements:**

Type: Animated correlation heatmap
Axes:
Both axes represent the following variables:
Unit price
Quantity
Tax 5%
Total
cogs (cost of goods sold)
gross income
Rating
Data: Correlation coefficients between variables, calculated for each unit price
Animation: Progresses through different unit prices over time

 **Key Observations from the Graph **:

Unit Price: The snapshot shows correlations for a unit price of 40.
Strong Correlations:
Positive correlations:
Quantity and Total (1.00)
cogs and Total (1.00)
Quantity and cogs (1.00)
Gross income and Total (0.99)
Gross income and cogs (0.99)
Gross income and Quantity (0.98)
Negative correlations:
Rating and Unit price (-0.15)
Moderate Correlations:
Tax 5% and Total (0.64)
Tax 5% and cogs (0.64)
Tax 5% and Quantity (0.64)
Tax 5% and Gross income (0.63)
Weak Correlations: Most other variable pairs have weak or no correlations.

 **Interpretation:**

Quantity, Total, cogs, and Gross Income: These variables are highly correlated, suggesting strong relationships between:
Quantity sold and total revenue
Cost of goods sold and total revenue
Quantity sold and cost of goods sold
Gross income and total revenue, cost of goods sold, and quantity sold
Unit Price and Rating: A weak negative correlation suggests a slight but consistent tendency for higher unit prices to be associated with lower customer ratings.
Tax 5%: Moderate correlations with revenue-related variables suggest a moderate impact of tax on overall sales performance.
Dynamic Relationships: The animation likely reveals how these correlations change for different unit prices, providing insights into the effects of pricing on sales, costs, gross income, and customer perceptions.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import seaborn as sns
import plotly.express as px

#Salary Distribution by Department
animated_salary_plot = px.scatter(supermarket_sales, x='Product line', y='cogs', animation_frame='City',
                                  title='Animated cogs Distribution by Product line and City',
                                  labels={'cogs': 'cogs ($)', 'Product line': 'Product line', 'City': 'Performance Score'},
                                  range_y=[supermarket_sales['cogs'].min(), supermarket_sales['cogs'].max()])

# Increase the duration of each frame
animated_salary_plot.layout.updatemenus[0].buttons[0].args[1]["frame"]["duration"] = 1000  # 1000 milliseconds per frame

animated_salary_plot.show()

"""**Objective:**

To visualize and analyze the distribution of cogs (cost of goods sold) across different product lines and cities.
To identify patterns and potential areas for cost optimization or pricing adjustments.
To understand how cogs relate to performance scores (cities).

 **Analysis:**

Key Features of the Graph: Animated scatter plot with product lines on the x-axis, cogs on the y-axis, and cities as animation frames.
Variation in cogs: Significant differences in cogs values among product lines, with Food and Beverages having the highest and Electronic Accessories having the lowest.
City-Specific Patterns: Variations in cogs values for certain product lines across cities, such as higher cogs in Health and Beauty, Home and Lifestyle, and Sports and Travel in Yangon compared to other cities.

 **Interpretation:**

Cost Structure Variations: The varying cogs across product lines suggest differences in cost structures, potentially due to product types, sourcing, or pricing strategies.
City-Specific Considerations: The city-specific patterns imply potential influences of local factors like supplier costs, logistics, or market competition.
Performance Score Implications: The association of cogs with performance scores (cities) highlights the importance of cost management for profitability.
"""

# Animated plot for Salary vs. Performance Score across Departments
animated_salary_perf_plot = px.scatter(supermarket_sales, x='City', y='cogs', animation_frame='Customer type',
                                       title='cogs vs. Product line by Customer type',
                                       labels={'cogs': 'cogs ($)', 'cogs': 'Product line', 'Customer type': 'Customer type'},
                                       range_y=[supermarket_sales['cogs'].min(), supermarket_sales['cogs'].max()])
# Increase the duration of each frame
animated_salary_perf_plot.layout.updatemenus[0].buttons[0].args[1]["frame"]["duration"] = 1000  # 1000 milliseconds per frame

animated_salary_perf_plot.show()

"""**Objective:**

To visualize and analyze the relationship between cogs (cost of goods sold) and customer type across different cities.
To identify patterns in cogs based on customer type and city.
To potentially uncover opportunities for cost optimization or customer-specific strategies.
 Analysis of the Graph:

**Key Features:**

Animated scatter plot with cities on the x-axis, cogs on the y-axis, and customer type as animation frames.
Markers represent cogs for different product lines (although the x-axis is labeled as City, the markers' horizontal positions seem to represent product lines).
Animation allows for comparisons between Member and Normal customer types.

** Key Observations:**

Variation Across Product Lines: Cogs values differ significantly among product lines for both customer types.
Customer Type Differences: Cogs patterns for certain product lines vary between Member and Normal customers in some cities.
City-Specific Trends: Cogs values for specific product lines and customer types show distinct patterns within each city.
Yangon: Notable differences in cogs for Health and Beauty, Home and Lifestyle, and Sports and Travel between Member and Normal customers.
Mandalay: Distinct patterns in cogs for Food and Beverages and Fashion Accessories between Member and Normal customers.
Naypyitaw: Less pronounced differences in cogs between customer types, but some variations exist for Sports and Travel and Electronic Accessories.

**Acknowledgment**



In the course of developing this project, I would like to extend my appreciation to various external sources that have played a pivotal role in enriching the content and outcomes. The datasets utilized in this project were sourced from Kaggle, a prominent platform in the realm of data science and machine learning. Valuable insights and information were also derived from ChatGPT, a language model developed by OpenAI, which provided assistance and guidance throughout the project. Additionally, the collaborative nature of GitHub was leveraged, with reference to various open-source repositories, contributing to the successful implementation of specific functionalities. Acknowledgment is extended to these platforms and their contributors for their collective efforts in enhancing the quality and depth of this project. It is important to note that compliance with the terms of use and licensing agreements associated with these data sources has been ensured, and any specific guidelines regarding acknowledgment or citation have been duly followed.
"""

